
// включённые библиотеки в проекте
# include <stdio.h>
# include <stdlib.h>
# include <math.h>

// пользовательский модуль для работы с матрицами
# include "matrixModule.h"

// основное тело программы
int main(){

// создаём константу, для хранения размерности системы (4 уравнения = 4 неизвестных)
const int N = 2; 
// создаём константу для хранения точности вычисления
const float epsilon = 0.00001;
// переменная для хранения количества иттераций
int count = 0;

// создаём указатель на матрицу
double **matrix;

// выделяем память под расширенную матрицу
matrix = init_matr(N, N + 1);
// выделяем память под массив ответов
double *result = malloc(N * sizeof(double));

// записываем значения в матрицу
matrix = read_matr(matrix, N, N + 1);

// выводим расширеную матрицу на экран
puts("Ваша расширенная матрица:");
print_matr(matrix, N, N + 1);

// основной цикл программы для метода Гаусса
for(int i = 0; i <= (N - 1); i++){

    // проверка условия, что элемент диагонали не равен 0
    if(fabs(matrix[i][i]) < epsilon){

        // спускаемся на строку ниже
        int m = i + 1;

    // ищем строку, где элемент диагонали не раввен нулю
     while((m < N) && (fabs(matrix[m][i]) < epsilon)){
    // переходим на следующую строку
    m++; 
     }

    //  проверка на выход за предeлы массива
    if(m == N){
        puts("Система не имеет решения (не возможно найти ненулевый элемент таблицы)");
        exit;
     }

    // меняем строки местами, чтобы избежать деления на 0
    matrix = row_change(matrix, i, m, N + 1);
     }


// применяем правило прямоугольника для вычисления новых элементов
// работает по формуле
for(int j = i + 1; j <= N - 1; j++){
    for(int k = i + 1; k <= N; k++){
     matrix[j][k] = (matrix[j][k] * matrix[i][i] - matrix[i][k] * matrix[j][i]) / matrix[i][i];   
    }
} 

// обнуляем элементы ниже ведущего
for(int j = i + 1; j <= N - 1; j++){
    matrix[j][i] = 0;
}

// деление ведущей строки на ведущий элемент
for(int j = N; j >= i; j--){
    matrix[i][j] = matrix[i][j] / matrix[i][i];
}

//вывод результата иттераций
// увеличиваем счётчик иттераций
count = count + 1;
printf("%d-ая итерация: \n", count);
print_matr(matrix, N, N+1);
}

// обратный ход 
result[N - 1] = matrix[N -1][N];

// цикл для вычисления значения элементов от x0 до x3
for(int i = N - 2; i >= 0; i--){
    result[i] = matrix[i][N];
    for(int j = N - 1; j >= i + 1; j-- ){
        result[i] = result[i] - matrix[i][j] * result[j];
    }
}

// вывод результата вычисления
for(int i = 0; i < N; i++){
    printf("x%d = %lf\n", i, result[i]);
}

// освобождаем память указателя
matrix_free(matrix, N);
matrix = NULL; // помечаем указатель как свободный

return 0;
}

/* действия в консоли -- 
 создаём программу с подключённым модулем
  gcc matrixModule.c  gauss.c -o gaus_task
  
  запускаем исполняемый файл
  ./gaus_task  */